\documentclass{ecnreport}

\stud{Control \& Robotics Master}
\topic{Manipulator Modeling \& Control}

\begin{document}

\inserttitle{Manipulator Modeling \& Control}

\section{Content of this lab}

The goal of this lab is to program in C++ the three fundamentals models for robot manipulators:
\begin{itemize}
	\item Direct Geometric Model: what is the pose of the end-effector for a given joint configuration?
	\item Inverse Geometric Model: what joint values correspond to a given end-effector pose?
	\item Kinematic Model: what is the velocity screw of the end-effector when the joints move?
\end{itemize}
These models will be applied on three different robots, and used to perform basic point-to-point control.\\

As it is not a lab on C++, most of the code is already written and you only have to fill the required functions:
\begin{itemize}
	\item \texttt{Robot::init\_wMe()} to initialize the fixed transform between the wrist and end-effector
	\item \texttt{Robot::fMw(q)} for the direct geometric model wrist-to-fixed frame
	\item \texttt{Robot::inverseGeometry(M)} for...well, the inverse geometry
	\item \texttt{Robot::fJw} for the kinematic model wrist-to-fixed frame
\end{itemize}

\subsection{Installing and loading the lab in Qt Creator}

This project uses the ROS\footnote{Robot Operating System, http://www.ros.org} framework which imposes some particular steps to configure the environment. An actual ROS course will be held in the second semester, for now just configure as follows:

\begin{enumerate}
	\item Open a terminal and download the lab package: \texttt{rosdl ecn\_manip}.
	\item Run Qt Creator from the top screen icon
	\item Load the \texttt{ros/src/ecn\_manip/CMakeLists.txt} file through \texttt{File...open project}
	\item QtCreator asks for a compilation folder: give \texttt{ros/build/ecn\_manip}
	\item The files should be displayed and ready to compile and run
	\item Compilation is done by clicking the bottom-left hammer
	\item Run your program with the green triangle. It can be stopped by clicking on the red square
\end{enumerate}

\subsection{Expected work}

The {\bf only} files to be modified are:
\begin{itemize}
	\item \texttt{control.cpp}: main file where the control is done depending on the current robot mode
	\item \texttt{robot\_turret.cpp}: model of the RRP turret robot
	\item \texttt{robot\_kr16.cpp}: model of the industrial Kuka KR16 robot
	\item \texttt{robot\_ur10.cpp}: model of the Universal Robot UR-10
\end{itemize}
We will use the ViSP\footnote{Visual Servoing Platform, http://visp.inria.fr} library to manipulate mathematical vectors and matrices, including frame transforms, rotations, etc. The main classes are detailed in Appendix \ref{visp}.\\
At the end of the lab, you should upload them through the \link{http://pagesperso.ls2n.fr/~kermorgant-o/student links.php}{portal on my website}

\section{The robots}

\def\wMe{{}^w\M_e}

Three robots are proposed with increasing complexity. You should start with the Turret, then the Kuka KR16 then the UR-10.\\
For each of these robots, the table of Modified Denavit-Hartenberg parameters should be defined. As we saw during the lectures, once you have the table then the Direct Geometric and Direct Kinematic Models can be almost automatically derived. A tool is provided in this package to generate C++ code for the Geometric and Kinematic models, see Appendix \ref{dhcode} for details on this tool.

The fixed frame and the end-effector frame are imposed by the schematics. 
All intermediary frames have to be placed according to MDH convention, with a final fixed transform between the wrist and end-effector frames.

\subsection{Turret RRP robot}

\begin{minipage}{.8\linewidth}
	This is a very simple robot to begin the modeling, as shown in the figure.\\
	The fixed frame $\Frame{0}$ and end-effector frame $\Frame{e}$ are imposed, as well as the joint direction.\\
	The constant values for this model are: $b = 0.5$ m and $d = 0.1$ m.\\~\\
	All computation may be done first without using the Denavit-Hartenberg parameters as the robot is quite simple. 
\end{minipage}
\begin{minipage}{.2\linewidth}
	\includegraphics{fig/turret}\label{turret}
\end{minipage}

\subsection{Kuka KR16 anthropomorphic robot}

This robot is a classical 6R architecture with a spherical wrist, as shown in the next figure:

\begin{figure}[h!]\centering
	\includegraphics[width=.6\linewidth]{fig/kr16}
	\caption{Model of the Kuka KR16 with imposed fixed and end-effector frames}
\end{figure}

The wrist frame is typically at the common point between joints 4, 5 and 6.
The constant transform $\wMe$ between the wrist and the end-effector should thus include the $0.158$ distance and potential rotations.

\subsection{Running the simulation}

Once everything is installed and compiled, the base simulation can be run from a terminal (only 1 line depending on the robot you work on):
\cppstyle
\begin{lstlisting}
roslaunch ecn_manip turret.launch
roslaunch ecn_manip kr16.launch
roslaunch ecn_manip ur10.launch
\end{lstlisting}


\section{Building the models}

\subsection*{The main code}

In the file \texttt{control.cpp}, the switch-case block corresponds to the 6 exercises to be done for each robot. Note that if they work for the Turret robot, then 
they should work for all robots as long as the model is correct. \\
The current exercise is changed by using the buttons in the GUI.

\subsection*{Exercise 1: Checking the Direct Geometric Model}

In this exercise, the robot follows the manually given joint positions. The task is to build and print the direct geometric model, depending on the current value of $\q$. This is to be done in two functions:
\begin{itemize}
	\item \texttt{Robot::init\_wMe()} where you have to write the constant matrix $\wMe$ from the end-effector to the wrist frame
	\item \texttt{Robot::fMw(q)}  where you have to write and return the transform $\M$ between the fixed and wrist frame
\end{itemize}
Once you have computed the \texttt{M} matrix, the code calls \texttt{robot->checkPose(M);} in order to print both your matrix and the true one. No need to tell that they should be equal.\\
What can be told is that it is useless to continue until they are.

\subsection*{Exercise 2: Checking the Direct Kinematic Model (Jacobian)}

If you select \texttt{Manual Operational Velocity} in the GUI then the sliders allow you to give a desired operational velocity (ie twist) for the end-effector.\\
The robot Jacobian has to be defined in the function \texttt{Robot::fJw(q)} that should return the Jacobian of the wrist in the fixed frame.\\

In the main code, the commanded velocity has then to be mapped to the joint velocity through the robot Jacobian: \texttt{vCommand = robot->fJe(q).pseudoInverse()*v;}\\
You can check that the end-effector is able to follow straight 3D lines in x, y or z direction. Similarly, it should be able to rotate around x, y or z. This means the Jacobian computation is correct.

\subsection*{Exercise 3: Checking the Inverse Geometric Model}

If you select \texttt{Direct point-to-point} in the GUI then the robot will receive two operational setpoints, at a given sampling time that can be changed with the \texttt{Switching time} slider in the GUI. The current setpoint is in the matrix \texttt{Md} and its corresponding joint position is in the vector \texttt{qf}. 

Nothing has to be done in the main code, but of course the \texttt{Robot::inverseGeometry(M)} function has to be filled in order to compute the actual inverse geometry solution.

\subsection*{Exercise 4: Interpolated point-to-point control}

\subsection*{Exercise 5: Inverse Geometric Model and trajectory tracking}

\subsection*{Exercise 6: Operational control through Jacobian}






\appendix


\newpage

\section{Using ViSP}\label{visp}

ViSP is a library for Visual Servoing (wait for the M2 Robotics to know more!) and also includes all necessary tools to play with mathematical vectors, matrices and 3D transforms.
The full documentation is here: \link{http://visp-doc.inria.fr/doxygen/visp-3.1.0/classes.html}{http://visp-doc.inria.fr/doxygen/visp-3.1.0/classes.html}.\\
The main classes to be used are:
\begin{itemize}
	\item \texttt{vpMatrix}: a classical matrix of given dimensions, can be multiplied with other matrices and vectors if the dimensions are ok. The pseudo-inverse of matrix \texttt{M} 
	is available with \texttt{M.pseudoInverse()}
	\item \texttt{vpColVector}: a column vector of given dimension
	\item \texttt{vpHomogeneousMatrix}: the classical $4\times 4$ 3D transform matrix
\end{itemize}
Most of the model computation is about initializing a matrix or vector to correct dimensions (which is already done) and fill its elements with formulae.\\
To write 1 at element (i,j) of matrix M, just write \texttt{M[i][j] = 1;}\\
Similarly, to write 1 at element (i) of vector q, just write \texttt{q[i] = 1;}


\newpage
\section{Code generation from Modified Denavit-Hartenberg parameters}\label{dhcode}

The core of robot modeling is to build the MDH table. From this, the DGM and KM can be derived automatically. The Inverse Geometry still has to be done by hand (even if some advanced tools allow code-generation for the IG resolution).

As it is quite tedious to have to compute all matrices when a solution of MDH is investigated, a tool is provided to generate the C++ code. An example can be found in the file \texttt{dh\_example.yml}:
\cppstyle
\begin{lstlisting}
notation: [alpha, a, theta, r]
joint:
1: [0, 0, q1, 0]
2: [-pi/2, 0, 0, q2]
3: [pi/2, 0, q3, r3]
4: [-pi/2, a4, q4+pi/2, 0]
\end{lstlisting}
The command to be run is: \texttt{rosrun ecn\_manip dh\_code.py <name of the file>}.\\
In the case of the above MDH table, it leads to these outputs:

\begin{minipage}{.45\linewidth}
\cppstyle \raggedright
\begin{lstlisting}
// Generated pose code                                                                                                                                                                                                                  
const double c1 = cos(q[0]);                                                                                                                                                                                                            
const double c1p3 = cos(q[0]+q[2]);                                                                                                                                                                                                     
const double c4 = cos(q[3]);                                                                                                                                                                                                            
const double s1 = sin(q[0]);                                                                                                                                                                                                            
const double s1p3 = sin(q[0]+q[2]);                                                                                                                                                                                                     
const double s4 = sin(q[3]);                                                                                                                                                                                                            
M[0][0] = -s4*c1p3;                                                                                                                                                                                                                     
M[0][1] = -c4*c1p3;                                                                                                                                                                                                                     
M[0][2] = -s1p3;                                                                                                                                                                                                                        
M[0][3] = a4*c1p3 - q[1]*s1;                                                                                                                                                                                                            
M[1][0] = -s4*s1p3;
M[1][1] = -s1p3*c4;
M[1][2] = c1p3;
M[1][3] = a4*s1p3 + q[1]*c1;
M[2][0] = -c4;
M[2][1] = s4;
M[2][2] = 0;
M[2][3] = r3;
M[3][0] = 0;
M[3][1] = 0;
M[3][2] = 0;
M[3][3] = 1.;
// End of pose code
\end{lstlisting}
\end{minipage}
\begin{minipage}{.1\linewidth}
	\quad\quad
\end{minipage}
\begin{minipage}{.45\linewidth}
\cppstyle \raggedright
\begin{lstlisting}
// Generated Jacobian code
const double c1 = cos(q[0]);
const double c1p3 = cos(q[0]+q[2]);
const double s1 = sin(q[0]);
const double s1p3 = sin(q[0]+q[2]);
J[0][0] = -a4*s1p3 - q[1]*c1;
J[0][1] = -s1;
J[0][2] = -a4*s1p3;
//J[0][3] = 0;
J[1][0] = a4*c1p3 - q[1]*s1;
J[1][1] = c1;
J[1][2] = a4*c1p3;
//J[1][3] = 0;
//J[2][0] = 0;
//J[2][1] = 0;
//J[2][2] = 0;
//J[2][3] = 0;
//J[3][0] = 0;
//J[3][1] = 0;
//J[3][2] = 0;
J[3][3] = -s1p3;
//J[4][0] = 0;
//J[4][1] = 0;
//J[4][2] = 0;
J[4][3] = c1p3;
J[5][0] = 1.;
//J[5][1] = 0;
J[5][2] = 1.;
//J[5][3] = 0;
// End of Jacobian code
\end{lstlisting}	
\end{minipage}
This is exactly what you would get by doing the manual computation from the initial table, which I hope is quite appreciated.







\end{document}
